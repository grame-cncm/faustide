{"version":3,"sources":["webpack:///./src/monaco-faust/Faust2MD.ts","webpack:///./src/monaco-faust/Faust2Doc.ts","webpack:///./src/monaco-faust/FaustLang.ts"],"names":["Faust2MD","fileName","Date","toLocaleDateString","line","idt","length","substr","matched","match","this","REGEX_BEG_TITLE","REGEX_END_TITLE","REGEX_BEG_SECTION","REGEX_END_SECTION","REGEX_BEG_COMMENT","REGEX_END_COMMENT","REGEX_INDENT","REGEX_COMMENT","strIn","optionsIn","options","tabsize","code","front","strOut","inComment","frontMatter","split","forEach","isComment","indentation","endC","matchEndComment","endS","matchEndSection","endT","matchEndTitle","outdent","c","matchBeginComment","s","matchBeginSection","t","matchBeginTitle","Faust2Doc","libs","exps","RegExp","REGEX_DEF_LIB","exp","push","namespace","imps","REGEX_DEF_IMP","str","REGEX_FUNC_NAME","getCondition","condsIn","conds","cond","result","REGEX_FUNC_NAME_COND","exec","found","index","subConds","splice","filter","el","map","replace","before","substring","after","subCond","getFile","depthIn","pathIn","docIn","depth","doc","path","curName","strBuffer","lines","i","getAllConditions","name","concat","join","matchLibrary","matchImport","j","lib","parse","imp","matchFuncName","language","id","extensions","mimetypes","config","comments","lineComment","blockComment","brackets","autoClosingPairs","open","close","notIn","theme","base","inherit","rules","token","foreground","colors","faustKeywords","faustFunctions","faust","a","fs","readFile","encoding","fetch","res","text","matchDocKey","model","position","line$","lineNumber","getLineContent","wordAtPosition","getWordAtPosition","column$","startColumn","word","prefixes","prefixWord","Position","nameArray","e","range","Range","endColumn","getProviders","libDocs","primDocs","console","error","faustLib","Object","keys","hoverProvider","provideHover","prefix","slice","pop","contents","value","faustDocURL","docSections","toLowerCase","tokensProvider","defaultToken","tokenPostfix","faustCompOperators","operators","symbols","escapes","tokenizer","root","cases","include","next","comment","string","whitespace","completionItemProvider","provideCompletionItems","suggestions","label","kind","languages","CompletionItemKind","Text","insertText","docs"],"mappings":"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","file":"js/333ba646ef01327190e3.js","sourcesContent":["/*\n\nUltra simple automatic documentation system for Faust.\nCreates a markdown file by extracting the comments from\na Faust file. The option -t n can be used to change the\ndefault (4) tab setting. The option -c can be used to\ninclude the Faust code itself into the generated doc.\nAnd the option -f can be used to include a YAML front\nmatter with the name of the file and the date.\n\nThe format of a title is :\n    //############# Title Name #################\n    //  markdown text....\n    //  markdown text....\n    //##########################################\n\nThe format of a section is :\n    //============== Section Name ==============\n    //  markdown text....\n    //  markdown text....\n    //==========================================\n\nThe format of a comment is :\n    //-------------- foo(x,y) ------------------\n    //  markdown text....\n    //  markdown text....\n    //------------------------------------------\neverything else is considered Faust code.\nThe translation is the following:\n  ## foo(x,y)\n    markdown text....\n    markdown text....\n--------------------------------------------------------\n*/\ntype Faust2MDOptions = { tabsize: number; code: boolean; front: boolean };\n/**\n * faust2md ts port\n *\n * @class Faust2MD\n */\nexport class Faust2MD {\n    private static readonly REGEX_BEG_TITLE = /^\\s*\\/\\/#{3,}\\s*([^#]*[^#\\s])\\s*#{3,}$/;\n    private static readonly REGEX_END_TITLE = /^\\s*((\\/\\/#{3,})|(\\s*))$/;\n    private static readonly REGEX_BEG_SECTION = /^\\s*\\/\\/={3,}\\s*([^=]*[^=\\s])\\s*={3,}$/;\n    private static readonly REGEX_END_SECTION = /^\\s*((\\/\\/={3,})|(\\s*))$/;\n    private static readonly REGEX_BEG_COMMENT = /^\\s*\\/\\/-{3,}\\s*([^-]*[^=\\s])\\s*-{3,}$/;\n    private static readonly REGEX_END_COMMENT = /^\\s*((\\/\\/-{3,})|(\\s*))$/;\n    private static readonly REGEX_INDENT = /(^\\s*\\/\\/\\s*)[^\\s]/;\n    private static readonly REGEX_COMMENT = /^\\s*\\/\\//;\n    /**\n     * Print the front matter of the file\n     *\n     * @static\n     * @param {string} fileName\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static frontMatter(fileName: string): string {\n        return \"---\\n\"\n        + `file: ${fileName}\\n`\n        + `date: ${new Date().toLocaleDateString()}\\n`\n        + \"---\\n\";\n    }\n    /**\n     * Outdent a comment line by n characters in\n     * order to remove the prefix \"//   \"\n     *\n     * @static\n     * @param {string} line\n     * @param {number} idt\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static outdent(line: string, idt: number): string {\n        return line.length <= idt ? \"\\n\" : line.substr(idt);\n    }\n    /**\n     * Match the first line of a title\n     * of type \"//#### Title ####\"\n     * at least 3 # are needed\n     *\n     * @static\n     * @param {string} line\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static matchBeginTitle(line: string): string {\n        const matched = line.match(this.REGEX_BEG_TITLE);\n        return matched ? matched[1] : null;\n    }\n    /**\n     * Match the last line of a title\n     * of type \"//########\"\n     * or a blank line\n     *\n     * @static\n     * @param {string} line\n     * @returns {boolean}\n     * @memberof Faust2MD\n     */\n    static matchEndTitle(line: string): boolean {\n        const matched = line.match(this.REGEX_END_TITLE);\n        return !!matched;\n    }\n    /**\n     * Match the first line of a section\n     * of type \"//==== Section ====\"\n     * at least 3 = are needed\n     *\n     * @static\n     * @param {string} line\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static matchBeginSection(line: string): string {\n        const matched = line.match(this.REGEX_BEG_SECTION);\n        return matched ? matched[1] : null;\n    }\n    /**\n     * Match the last line of a section\n     * of type \"//=======\"\n     * or a blank line\n     *\n     * @static\n     * @param {string} line\n     * @returns {boolean}\n     * @memberof Faust2MD\n     */\n    static matchEndSection(line: string): boolean {\n        const matched = line.match(this.REGEX_END_SECTION);\n        return !!matched;\n    }\n    /**\n     * Match the first line of a comment\n     * of type \"//--- foo(x,y) ----\"\n     * at least 3 - are needed\n     *\n     * @static\n     * @param {string} line\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static matchBeginComment(line: string): string {\n        const matched = line.match(this.REGEX_BEG_COMMENT);\n        return matched ? matched[1] : null;\n    }\n    /**\n     * Match the last line of a comment\n     * of type \"//-----------------\"\n     * or a blank line\n     *\n     * @static\n     * @param {string} line\n     * @returns {boolean}\n     * @memberof Faust2MD\n     */\n    static matchEndComment(line: string): boolean {\n        const matched = line.match(this.REGEX_END_COMMENT);\n        return !!matched;\n    }\n    /**\n     * Measure the indentation of a md-comment line\n     * that is the len of the prefix '//   '\n     *\n     * @static\n     * @param {string} line\n     * @returns {number}\n     * @memberof Faust2MD\n     */\n    static indentation(line: string): number {\n        const matched = line.match(this.REGEX_INDENT);\n        return matched ? matched[1].length : 0;\n    }\n    /**\n     * Indicates if a line is a comment\n     *\n     * @static\n     * @param {string} line\n     * @returns {boolean}\n     * @memberof Faust2MD\n     */\n    static isComment(line: string): boolean {\n        const matched = line.match(this.REGEX_COMMENT);\n        return !!matched;\n    }\n    /**\n     * Process the file\n     *\n     * @static\n     * @param {string} strIn\n     * @param {string} [fileName]\n     * @param {{ tabsize?: number, code?: boolean, front?: boolean }} [optionsIn]\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static parse(strIn: string, fileName?: string, optionsIn?: { tabsize?: number; code?: boolean; front?: boolean }): string {\n        const options: Faust2MDOptions = { tabsize: 4, code: false, front: false, ...optionsIn };\n        let strOut = \"\";\n        let inComment = false; // false: in code; true: in md-comment\n        let idt = 0; // indentation retained to outdent comment lines\n        if (options.front && fileName) strOut += this.frontMatter(fileName);\n        strIn.split(\"\\n\").forEach((line) => {\n            if (!this.isComment(line)) {\n                if (inComment) { // we are closing a md-comment\n                    strOut += \"\\n\";\n                    inComment = false;\n                }\n                if (options.code) strOut += `\\t${line}\\n`;\n                return;\n            }\n            if (inComment) { // we are in a md-comment\n                if (idt === 0) idt = this.indentation(line); // we have to measure the indentation\n                // check end of md-comment\n                const { endC, endS, endT } = { endC: this.matchEndComment(line), endS: this.matchEndSection(line), endT: this.matchEndTitle(line) };\n                if (endC) strOut += \"\\n---\\n\\n\";\n                if (endC || endS || endT) inComment = false; // end of md-comment switch back to mode O\n                else strOut += this.outdent(line, idt) + \"\\n\";\n                return;\n            }\n            // check begin of md-comment\n            const { c, s, t } = { c: this.matchBeginComment(line), s: this.matchBeginSection(line), t: this.matchBeginTitle(line) };\n            if (c) strOut += `\\n### ${c}\\n`;\n            else if (s) strOut += `\\n## ${s}\\n`;\n            else if (t) strOut += `\\n# ${t}\\n`;\n            if (c || s || t) {\n                inComment = true;\n                idt = 0;\n            } else if (options.code) strOut += `\\t${line}\\n`;\n        });\n        return strOut;\n    }\n}\n","/* eslint-disable no-await-in-loop */\nimport { Faust2MD } from \"./Faust2MD\";\n/*\nRetrive faust2md doc by parsing .dsp file\n\nThe format of a title is :\n    //############# Title Name #################\n    //  markdown text....\n    //  markdown text....\n    //##########################################\n\nThe format of a section is :\n    //============== Section Name ==============\n    //  markdown text....\n    //  markdown text....\n    //==========================================\n\nThe format of a comment is :\n    //-------------- foo(x,y) ------------------\n    //  markdown text....\n    //  markdown text....\n    //------------------------------------------\neverything else is considered Faust code.\n--------------------------------------------------------\n*/\nexport type TFaustDocs = { [key: string]: TFaustDoc };\nexport type TFaustDoc = { path: string[]; name: string; doc: string };\n/**\n *\n * @class Faust2Doc\n */\nexport class Faust2Doc {\n    private static readonly REGEX_DEF_LIB = /\\b(\\w+)\\s*=\\s*library\\(\"(.+)\"\\);/;\n    private static readonly REGEX_DEF_IMP = /\\bimport\\(\"(.+)\"\\);/;\n    private static readonly REGEX_FUNC_NAME = /`.*?([\\w[\\]|]+)`/;\n    private static readonly REGEX_FUNC_NAME_COND = /\\[(.+?)(\\|.+?)*?]/;\n    /**\n     * Retrieve a library definition\n     *\n     * @static\n     * @param {string} line\n     * @returns {{ namespace: string, fileName: string }[]}\n     * @memberof Faust2Doc\n     */\n    static matchLibrary(line: string): { namespace: string; fileName: string }[] {\n        const libs = [] as { namespace: string; fileName: string }[];\n        const exps = line.match(new RegExp(this.REGEX_DEF_LIB, \"g\"));\n        if (exps) {\n            exps.forEach((exp) => {\n                const matched = exp.match(this.REGEX_DEF_LIB);\n                if (matched) libs.push({ namespace: matched[1], fileName: matched[2] });\n            });\n        }\n        return libs;\n    }\n    /**\n     * Retrieve an import expression\n     *\n     * @static\n     * @param {string} line\n     * @returns {string[]}\n     * @memberof Faust2Doc\n     */\n    static matchImport(line: string): string[] {\n        const imps = [] as string[];\n        const exps = line.match(new RegExp(this.REGEX_DEF_IMP, \"g\"));\n        if (exps) {\n            exps.forEach((exp) => {\n                const matched = exp.match(this.REGEX_DEF_IMP);\n                if (matched) imps.push(matched[1]);\n            });\n        }\n        return imps;\n    }\n    /**\n     * Retrieve true function name from string in comments\n     * `(si.)bus`\n     *\n     * @static\n     * @param {string} str\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static matchFuncName(str: string): string {\n        const matched = str.match(this.REGEX_FUNC_NAME);\n        return matched ? matched[1] : null;\n    }\n    /**\n     * Get all conditions in func name like `[third|half]_octave_[analyzer|filterbank][n]`\n     *\n     * @static\n     * @param {string} str\n     * @returns {string[]}\n     * @memberof Faust2Doc\n     */\n    static getAllConditions(str: string): string[] {\n        return this.getCondition([str]);\n    }\n    /**\n     * getAllConditions Recursive body\n     *\n     * @static\n     * @param {string[]} [condsIn]\n     * @param {RegExp} [regexp]\n     * @returns {string[]}\n     * @memberof Faust2Doc\n     */\n    private static getCondition(condsIn?: string[]): string[] {\n        const conds = [] as string[];\n        condsIn.forEach((cond) => {\n            const regexp = new RegExp(this.REGEX_FUNC_NAME_COND, \"g\");\n            const result = regexp.exec(cond);\n            if (!result) return;\n            const found = result[0];\n            const index = result.index;\n            const subConds = result.splice(1).filter(el => typeof el === \"string\").map(str => str.replace(/^\\|/, \"\"));\n            const before = cond.substring(0, index);\n            const after = cond.substring(index + found.length);\n            if (subConds.length === 1) {\n                conds.push(before + after);\n                conds.push(before + subConds + after);\n            } else {\n                subConds.forEach(subCond => conds.push(before + subCond + after));\n            }\n        });\n        return conds.length ? this.getCondition(conds) : condsIn;\n    }\n    /**\n     * Process the file\n     *\n     * @static\n     * @param {string} fileName fileName to be fetch using getFile\n     * @param {string} getFile callback used for import and library expressions\n     * @param {string[]} [depthIn] current Depth, stop when 0;\n     * @param {string[]} [pathIn] path of current namespace\n     * @param {string} [docIn] recursive accum object for output\n     * @returns {Promise<TFaustDocs>}\n     * @memberof Faust2MD\n     */\n    static async parse(fileName: string, getFile: (fileName: string) => Promise<string>, depthIn?: number, pathIn?: string[], docIn?: TFaustDocs): Promise<TFaustDocs> {\n        if (depthIn === 0) return docIn;\n        const depth = depthIn || 2;\n        const strIn = await getFile(fileName);\n        const doc: TFaustDocs = docIn || {};\n        const path = pathIn || [];\n        let inComment = false; // false: in code; true: in md-comment\n        let idt = 0; // indentation retained to outdent comment lines\n        let curName = \"\"; // current function name\n        let strBuffer = \"\"; // current function doc\n        const lines = strIn.split(\"\\n\");\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            if (!line) continue; // empty line\n            if (!Faust2MD.isComment(line)) {\n                if (inComment) { // we are closing a md-comment\n                    inComment = false;\n                    if (curName) this.getAllConditions(curName).forEach(name => doc[path.concat(name).join(\".\")] = { name: curName, path: [...path], doc: strBuffer });\n                    curName = \"\";\n                    strBuffer = \"\";\n                }\n                const libs = this.matchLibrary(line);\n                const imps = this.matchImport(line);\n                for (let j = 0; j < libs.length; j++) {\n                    const lib = libs[j];\n                    await this.parse(lib.fileName, getFile, depth - 1, [...path, lib.namespace], doc);\n                }\n                for (let j = 0; j < imps.length; j++) {\n                    const imp = imps[j];\n                    await this.parse(imp, getFile, depth - 1, path, doc);\n                }\n                continue;\n            }\n            if (inComment) { // we are in a md-comment (not first line)\n                if (idt === 0) idt = Faust2MD.indentation(line); // we have to measure the indentation\n                // check end of md-comment\n                const { endC, endS, endT } = { endC: Faust2MD.matchEndComment(line), endS: Faust2MD.matchEndSection(line), endT: Faust2MD.matchEndTitle(line) };\n                if (endC || endS || endT) inComment = false; // end of md-comment switch back to mode O\n                else strBuffer += Faust2MD.outdent(line, idt) + \"\\n\";\n                if (endC) { // pop buffer\n                    if (curName) this.getAllConditions(curName).forEach(name => doc[path.concat(name).join(\".\")] = { name: curName, path: [...path], doc: strBuffer });\n                    curName = \"\";\n                    strBuffer = \"\";\n                }\n                continue;\n            }\n            // check begin of md-comment\n            const { c, s, t } = { c: Faust2MD.matchBeginComment(line), s: Faust2MD.matchBeginSection(line), t: Faust2MD.matchBeginTitle(line) };\n            if (c) curName = this.matchFuncName(c);\n            if (c || s || t) {\n                inComment = true;\n                idt = 0;\n                strBuffer = \"\";\n            }\n        }\n        return doc;\n    }\n}\n","import { languages, editor, Position, Range } from \"monaco-editor/esm/vs/editor/editor.api\";\nimport { Faust } from \"faust2webaudio\";\nimport { Faust2Doc, TFaustDocs, TFaustDoc } from \"./Faust2Doc\";\n\nimport { docSections, faustDocURL } from \"../documentation\"; \n\nexport type FaustLanguageProviders = {\n    hoverProvider: languages.HoverProvider;\n    tokensProvider: languages.IMonarchLanguage;\n    completionItemProvider: languages.CompletionItemProvider;\n    docs: TFaustDocs;\n};\nexport const language: languages.ILanguageExtensionPoint = {\n    id: \"faust\",\n    extensions: [\"dsp\", \"lib\"],\n    mimetypes: [\"application/faust\"]\n};\nexport const config: languages.LanguageConfiguration = {\n    comments: {\n        lineComment: \"//\",\n        blockComment: [\"/*\", \"*/\"]\n    },\n    brackets: [\n        [\"{\", \"}\"],\n        [\"[\", \"]\"],\n        [\"(\", \")\"]\n    ],\n    autoClosingPairs: [\n        { open: \"{\", close: \"}\" },\n        { open: \"[\", close: \"]\" },\n        { open: \"(\", close: \")\" },\n        { open: '\"', close: '\"', notIn: [\"string\"] },\n        { open: \"/*\", close: \"*/\", notIn: [\"string\"] }\n    ]\n};\nexport const theme: editor.IStandaloneThemeData = {\n    base: \"vs-dark\",\n    inherit: true,\n    rules: [\n        { token: \"faustFunctions\", foreground: \"DDDD99\" },\n        { token: \"faustKeywords\", foreground: \"4499CC\" },\n        { token: \"faustLib\", foreground: \"CCCCBB\" },\n        { token: \"faustCompOperators\", foreground: \"FFDDFF\" },\n        { token: \"identifier\", foreground: \"77CCFF\" }\n    ],\n    colors: null\n};\nconst faustKeywords = [\n    \"import\", \"component\", \"declare\", \"library\", \"environment\", \"int\", \"float\",\n    \"letrec\", \"with\", \"class\", \"process\", \"effect\", \"inputs\", \"outputs\"\n];\nconst faustFunctions = [\n    \"mem\", \"prefix\", \"rdtable\", \"rwtable\",\n    \"select2\", \"select3\", \"ffunction\", \"fconstant\", \"fvariable\",\n    \"route\", \"waveform\", \"soundfile\",\n    \"button\", \"checkbox\", \"vslider\", \"hslider\", \"nentry\",\n    \"vgroup\", \"hgroup\", \"tgroup\", \"vbargraph\", \"hbargraph\", \"attach\",\n    \"acos\", \"asin\", \"atan\", \"atan2\", \"cos\", \"sin\", \"tan\", \"exp\",\n    \"log\", \"log10\", \"pow\", \"sqrt\", \"abs\", \"min\", \"max\", \"fmod\",\n    \"remainder\", \"floor\", \"ceil\", \"rint\",\n    \"seq\", \"par\", \"sum\", \"prod\"\n];\nconst getFile = async (fileName: string, faust: Faust) => {\n    if (faust) return faust.fs.readFile(\"libraries/\" + fileName, { encoding: \"utf8\" }) as string;\n    const libPath = \"https://faustlibraries.grame.fr/libs/\";\n    const res = await fetch(libPath + fileName);\n    return res.text();\n};\ntype TMatchedFaustDoc = { nameArray: string[]; name: string; range: Range; doc: TFaustDoc };\n/**\n * Match an available doc key from monaco editor\n *\n * @param {TFaustDocs} doc\n * @param {editor.ITextModel} model\n * @param {Position} position\n * @returns {TMatchedFaustDoc} full: [...prefixes, name], range: a monaco range object, doc: a FaustDoc object\n */\nexport const matchDocKey = (doc: TFaustDocs, model: editor.ITextModel, position: Position): TMatchedFaustDoc => {\n    const line$ = position.lineNumber;\n    const line = model.getLineContent(line$);\n    const wordAtPosition = model.getWordAtPosition(position);\n    if (!wordAtPosition) return null;\n    let column$ = wordAtPosition.startColumn - 1;\n    const name = wordAtPosition.word;\n    const prefixes: string[] = [];\n    while (column$ - 2 >= 0 && line[column$ - 1] === \".\") {\n        column$ -= 2;\n        const prefixWord = model.getWordAtPosition(new Position(line$, column$));\n        prefixes.splice(0, 0, prefixWord.word);\n        column$ = prefixWord.startColumn - 1;\n    }\n    const nameArray = [...prefixes, name];\n    while (nameArray.length) {\n        const name = nameArray.join(\".\");\n        const e = doc[name];\n        if (e) {\n            return {\n                nameArray,\n                name,\n                range: new Range(line$, column$ + 1, line$, wordAtPosition.endColumn),\n                doc: e\n            };\n        }\n        column$ += nameArray.splice(0, 1)[0].length + 1;\n    }\n    return null;\n};\nexport const getProviders = async (faust: Faust): Promise<FaustLanguageProviders> => {\n    let libDocs: TFaustDocs = {};\n    let primDocs: TFaustDocs = {};\n    try {\n        libDocs = await Faust2Doc.parse(\"stdfaust.lib\", async (fileName: string) => getFile(fileName, faust));\n        primDocs = await Faust2Doc.parse(\"primitives.lib\", async (fileName: string) => getFile(fileName, faust));\n    } catch (e) { console.error(e); } // eslint-disable-line no-empty, no-console\n    const faustLib = Object.keys(libDocs);\n\n    const hoverProvider: languages.HoverProvider = {\n        provideHover: (model, position) => {\n            const matched = matchDocKey({ ...primDocs, ...libDocs }, model, position);\n            if (matched) {\n                const prefix = matched.nameArray.slice();\n                const name = prefix.pop();\n                const doc = matched.doc;\n                return {\n                    range: matched.range,\n                    contents: [\n                        { value: `\\`\\`\\`\\n${prefix.length ? \"(\" + prefix.join(\".\") + \".)\" : \"\"}${name}\\n\\`\\`\\`` },\n                        { value: doc.doc.replace(/#+/g, \"######\") },\n                        { value: prefix.length ? `[Detail...](${faustDocURL}/${docSections[prefix.slice(0, 2)]}/#${prefix.join(\".\")}${doc.name.replace(/[[\\]|]/g, \"\").toLowerCase()})` : \"[Detail...](https://faustdoc.grame.fr/manual/syntax/index.html#faust-syntax)\" }\n                    ]\n                };\n            }\n            return null;\n        }\n    };\n    const tokensProvider: languages.IMonarchLanguage = ({\n        faustKeywords,\n        faustFunctions,\n        faustLib,\n        defaultToken: \"invalid\",\n        tokenPostfix: \".dsp\",\n        faustCompOperators: [\n            \"~\", \",\", \":\", \"<:\", \":>\"\n        ],\n        operators: [\n            \"=\",\n            \"+\", \"-\", \"*\", \"/\", \"%\", \"^\",\n            \"&\", \"|\", \"xor\", \"<<\", \">>\",\n            \">\", \"<\", \"==\", \"<=\", \">=\", \"!=\",\n            \"@\", \"'\"\n        ],\n        // we include these common regular expressions\n        symbols: /[=><!~?:&|+\\-*/^%]+/,\n        // C# style strings\n        escapes: /\\\\(?:[abfnrtv\\\\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,\n        // The main tokenizer for our languages\n        tokenizer: {\n            root: [\n                // identifiers and keywords\n                [/!|_/, \"keyword\"],\n                [/[a-z_$]([\\w.$]*[\\w$])?/, {\n                    cases: {\n                        \"@faustFunctions\": \"faustFunctions\",\n                        \"@faustKeywords\": \"faustKeywords\",\n                        \"@faustLib\": \"faustLib\",\n                        \"@default\": \"identifier\"\n                    }\n                }],\n                [/[A-Z][\\w$]*/, \"type.identifier\"],\n                // whitespace\n                { include: \"@whitespace\" },\n                // delimiters and operators\n                [/[{}()[\\]]/, \"@brackets\"],\n                [/~|,|<:|:>|:/, \"faustCompOperators\"],\n                [/[<>](?!@symbols)/, \"@brackets\"],\n                [/=|\\+|-|\\*|\\/|%|\\^|&|\\||xor|<<|>>|>|<|==|<=|>=|!=|@|'/, {\n                    cases: {\n                        \"@operators\": \"operators\",\n                        \"@default\": \"\"\n                    }\n                }],\n                // numbers\n                [/\\d*\\.\\d+([eE][-+]?\\d+)?/, \"number.float\"],\n                [/0[xX][0-9a-fA-F]+/, \"number.hex\"],\n                [/\\d+/, \"number\"],\n                // delimiter: after number because of .\\d floats\n                [/[;.]/, \"delimiter\"],\n                // strings\n                [/\"/, { token: \"string\", next: \"@string\" }]\n            ],\n            comment: [\n                [/[^/*]+/, \"comment\"],\n                [/\\/\\*/, \"comment\", \"@push\"],\n                [/\\*\\//, \"comment\", \"@pop\"],\n                [/[/*]/, \"comment\"]\n            ],\n            string: [\n                [/[^\\\\\"$]+/, \"string\"],\n                [/@escapes/, \"string.escape\"],\n                [/\\\\./, \"string.escape.invalid\"],\n                [/\"/, \"string\", \"@pop\"]\n            ],\n            whitespace: [\n                [/[ \\t\\r\\n]+/, \"white\"],\n                [/\\/\\*/, \"comment\", \"@comment\"],\n                [/\\/\\/.*$/, \"comment\"]\n            ]\n        }\n    } as any);\n    const completionItemProvider: languages.CompletionItemProvider = {\n        provideCompletionItems: () => {\n            const suggestions: languages.CompletionItem[] = [];\n            [...faustKeywords, ...faustFunctions, ...faustLib].forEach((e) => {\n                suggestions.push({\n                    label: e,\n                    kind: languages.CompletionItemKind.Text,\n                    insertText: e,\n                    range: null\n                });\n            });\n            return { suggestions };\n        }\n    };\n    return { hoverProvider, tokensProvider, completionItemProvider, docs: libDocs };\n};\n"],"sourceRoot":""}